#include <gp_Instance.h>
#include <gp_Alloc.h>

gpInt gpInstance_SEQUENCE_SAMPLE_SIZE = 16;
gpInt gpInstance_PATCH_SAMPLE_SIZE = 16;

/*    gpFloat[] ORIENTATIONS = {
            0, (float) (gpMath_PI / 4), (float) (gpMath_PI / 2), (float) (gpMath_PI * 3 / 4),
            (float) gpMath_PI, -0, (float) (-gpMath_PI / 4), (float) (-gpMath_PI / 2),
            (float) (-gpMath_PI * 3 / 4), (float) -gpMath_PI
    };
*/

gpInstance* gpInstance_New(gpWord id, gpFloat* sample, gpWord size, gpString label)
{
	gpInstance* instance = gpAlloc_alloc(sizeof(gpInstance));
	instance->id = id;
	instance->vector = sample;
	instance->size = size;
	instance->label = label;
	return instance;
}

void gpInstance_normalize(gpFloat* vector, gpWord size) {
        gpFloat* sample = vector;
        gpFloat sum = 0;

        for (gpInt i = 0; i < size; i++) {
            sum = gpAdd(gpMul(sample[i], sample[i]), sum);
        }

        gpFloat magnitude = gpMath_sqrt(sum);
        for (int i = 0; i < size; i++) {
            sample[i] /= magnitude;
        }
    }
}

private static float[] spatialSampler(Gesture gesture) {
    return GestureUtils.spatialSampling(gesture, PATCH_SAMPLE_SIZE, false);
}

private static float[] temporalSampler(int orientationType, Gesture gesture) {
    float[] pts = GestureUtils.temporalSampling(gesture.getStrokes().get(0),
            SEQUENCE_SAMPLE_SIZE);
    float[] center = GestureUtils.computeCentroid(pts);
    float orientation = (float)Math.atan2(pts[1] - center[1], pts[0] - center[0]);

    float adjustment = -orientation;
    if (orientationType != GestureStore.ORIENTATION_INVARIANT) {
        int count = ORIENTATIONS.length;
        for (int i = 0; i < count; i++) {
            float delta = ORIENTATIONS[i] - orientation;
            if (Math.abs(delta) < Math.abs(adjustment)) {
                adjustment = delta;
            }
        }
    }

    GestureUtils.translate(pts, -center[0], -center[1]);
    GestureUtils.rotate(pts, adjustment);

    return pts;
}

*/
